---
import type { CollapsibleContent } from '../../types/content.ts';
import ContentRenderer from '../ContentRenderer.astro';

export interface Props {
  content: CollapsibleContent;
  group?: string; // Optional group name for accordion behavior
}

const { content, group } = Astro.props;
---

<div class="mb-6 border border-primary-200 dark:border-primary-700 rounded-lg overflow-hidden collapsible-container transition-colors duration-300" 
     data-initial-open={content.isOpen ? 'true' : 'false'}
     data-group={group || ''}>
  <button type="button" class="w-full px-6 py-4 bg-primary-50 dark:bg-primary-700 hover:bg-primary-100 dark:hover:bg-primary-600 cursor-pointer transition-colors duration-200 border-b border-primary-200 dark:border-primary-600 collapsible-summary text-left flex justify-between items-center">
    <span class="font-medium text-primary-900 dark:text-primary-100">{content.title}</span>
    <span class="collapsible-icon transition-transform duration-300">
      <svg class="w-5 h-5 text-primary-600 dark:text-primary-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
      </svg>
    </span>
  </button>
  <div class="collapsible-content">
    <div class="collapsible-inner px-6 py-4 bg-white dark:bg-primary-800 transition-colors duration-300">
      <div class="collapsible-text-content max-w-none">
        {content.nestedBlocks && content.nestedBlocks.length > 0 ? (
          <ContentRenderer blocks={content.nestedBlocks} />
        ) : (
          <div set:html={content.content} />
        )}
      </div>
    </div>
  </div>
</div>

<style>
  /* Clean collapsible styles */
  .collapsible-container {
    transition: box-shadow 0.2s ease-in-out;
  }
  
  .collapsible-container:hover {
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  }
  
  .dark .collapsible-container:hover {
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
  }
  
  .collapsible-summary {
    border: none;
    background: none;
    outline: none;
  }
  
  .collapsible-summary:focus {
    outline: none;
    box-shadow: none;
  }
  
  .collapsible-summary:focus-visible {
    outline: 2px solid #3b82f6;
    outline-offset: -2px;
  }
  
  /* Content hidden by default */
  .collapsible-content {
    height: 0;
    overflow: hidden;
    opacity: 0;
  }
  
  /* Icon starts pointing right */
  .collapsible-icon {
    transform: rotate(-90deg);
  }
  
  /* Open state */
  .collapsible-container.is-open .collapsible-icon {
    transform: rotate(0deg);
  }
  
  /* HIGH PRIORITY: Enhanced text contrast in collapsible content */
  .collapsible-text-content {
    font-size: 0.9375rem;
    line-height: 1.7;
  }
  
  .collapsible-text-content,
  .collapsible-text-content > div {
    color: #1e293b !important; /* primary-900 */
  }
  
  .dark .collapsible-text-content,
  .dark .collapsible-text-content > div {
    color: #f1f5f9 !important; /* primary-100 */
  }
  
  .collapsible-text-content strong,
  .collapsible-text-content b {
    color: #0f172a !important; /* primary-950 */
    font-weight: 600 !important;
  }
  
  .dark .collapsible-text-content strong,
  .dark .collapsible-text-content b {
    color: #ffffff !important;
    font-weight: 600 !important;
  }
  
  .collapsible-text-content p {
    color: #1e293b !important; /* primary-900 */
    margin-bottom: 0.75rem !important;
    line-height: 1.7 !important;
  }
  
  .dark .collapsible-text-content p {
    color: #f1f5f9 !important; /* primary-100 */
  }
  
  .collapsible-text-content ul,
  .collapsible-text-content ol {
    color: #334155 !important; /* primary-700 */
    margin-bottom: 0.75rem !important;
    padding-left: 1.5rem !important;
  }
  
  .dark .collapsible-text-content ul,
  .dark .collapsible-text-content ol {
    color: #e2e8f0 !important; /* primary-200 */
  }
  
  .collapsible-text-content li {
    margin-bottom: 0.375rem !important;
    color: #334155 !important; /* primary-700 */
  }
  
  .dark .collapsible-text-content li {
    color: #e2e8f0 !important; /* primary-200 */
  }
  
  .collapsible-text-content a {
    color: #059669 !important; /* accent-600 */
    text-decoration: underline !important;
  }
  
  .dark .collapsible-text-content a {
    color: #34d399 !important; /* accent-400 */
  }
  
  .collapsible-text-content a:hover {
    color: #047857 !important; /* accent-700 */
  }
  
  .dark .collapsible-text-content a:hover {
    color: #6ee7b7 !important; /* accent-300 */
  }
  
  /* Responsive adjustments */
  @media (max-width: 768px) {
    .collapsible-summary {
      padding: 1rem;
    }
    
    .collapsible-inner {
      padding-left: 1rem;
      padding-right: 1rem;
    }
  }
</style>

<script>
  // Web Animations API implementation for reliable collapsible animations
  document.addEventListener('DOMContentLoaded', function() {
    const collapsibleContainers = document.querySelectorAll('.collapsible-container');
    
    collapsibleContainers.forEach(container => {
      const button = container.querySelector('.collapsible-summary') as HTMLButtonElement;
      const content = container.querySelector('.collapsible-content') as HTMLElement;
      const icon = container.querySelector('.collapsible-icon') as HTMLElement;
      
      if (!button || !content || !icon) return;
      
      const shouldBeInitiallyOpen = container.getAttribute('data-initial-open') === 'true';
      let isOpen = shouldBeInitiallyOpen;
      let isAnimating = false;
      
      // Set initial state immediately - prevent flash
      if (isOpen) {
        container.classList.add('is-open');
        content.style.height = 'auto';
        content.style.opacity = '1';
      } else {
        container.classList.remove('is-open');
        content.style.height = '0px';
        content.style.opacity = '0';
      }
      
      // Get group information for accordion behavior
      const groupName = container.getAttribute('data-group');
      
      // Handle custom close event for accordion behavior
      button.addEventListener('forceClose', function(e) {
        e.preventDefault();
        
        // Only close if currently open and not already animating
        if (!isOpen || isAnimating) return;
        
        isAnimating = true;
        isOpen = false;
        
        // Closing animation
        container.classList.remove('is-open');
        
        // Get current height
        const currentHeight = content.scrollHeight;
        content.style.height = currentHeight + 'px';
        
        // Create closing animations
        const heightAnimation = content.animate([
          { height: currentHeight + 'px' },
          { height: '0px' }
        ], {
          duration: 350,
          easing: 'cubic-bezier(0.4, 0, 0.2, 1)',
          fill: 'forwards'
        });
        
        const opacityAnimation = content.animate([
          { opacity: '1' },
          { opacity: '0' }
        ], {
          duration: 250,
          easing: 'ease-in',
          fill: 'forwards'
        });
        
        // When animation completes
        Promise.all([heightAnimation.finished, opacityAnimation.finished]).then(() => {
          isAnimating = false;
        });
      });
      
      // Handle click events
      button.addEventListener('click', function(e) {
        e.preventDefault();
        
        // Prevent multiple concurrent animations
        if (isAnimating) return;
        
        // If this is part of a group and we're opening, close others in the group
        if (groupName && !isOpen) {
          const groupContainers = document.querySelectorAll(`[data-group="${groupName}"]`);
          groupContainers.forEach((otherContainer) => {
            if (otherContainer !== container && otherContainer.classList.contains('is-open')) {
              // Get the other container's state management
              const otherButton = otherContainer.querySelector('.collapsible-summary') as HTMLButtonElement;
              const otherContent = otherContainer.querySelector('.collapsible-content') as HTMLElement;
              
              if (otherContent && otherButton) {
                // Find and update the other container's state by accessing its closure variables
                // We'll use a custom event to properly close the other collapsible
                const closeEvent = new CustomEvent('forceClose', { detail: { skipGroupCheck: true } });
                otherButton.dispatchEvent(closeEvent);
              }
            }
          });
        }
        
        isAnimating = true;
        isOpen = !isOpen;
        
        if (isOpen) {
          // Opening animation
          container.classList.add('is-open');
          
          // Get target height by temporarily setting auto
          content.style.height = 'auto';
          const targetHeight = content.scrollHeight;
          content.style.height = '0px';
          
          // Create opening animations
          const heightAnimation = content.animate([
            { height: '0px' },
            { height: targetHeight + 'px' }
          ], {
            duration: 400,
            easing: 'cubic-bezier(0.4, 0, 0.2, 1)',
            fill: 'forwards'
          });
          
          const opacityAnimation = content.animate([
            { opacity: '0' },
            { opacity: '1' }
          ], {
            duration: 300,
            delay: 100,
            easing: 'ease-out',
            fill: 'forwards'
          });
          
          // When animation completes
          Promise.all([heightAnimation.finished, opacityAnimation.finished]).then(() => {
            content.style.height = 'auto';
            isAnimating = false;
          });
          
        } else {
          // Closing animation
          container.classList.remove('is-open');
          
          // Get current height
          const currentHeight = content.scrollHeight;
          content.style.height = currentHeight + 'px';
          
          // Create closing animations
          const heightAnimation = content.animate([
            { height: currentHeight + 'px' },
            { height: '0px' }
          ], {
            duration: 350,
            easing: 'cubic-bezier(0.4, 0, 0.2, 1)',
            fill: 'forwards'
          });
          
          const opacityAnimation = content.animate([
            { opacity: '1' },
            { opacity: '0' }
          ], {
            duration: 250,
            easing: 'ease-in',
            fill: 'forwards'
          });
          
          // When animation completes
          Promise.all([heightAnimation.finished, opacityAnimation.finished]).then(() => {
            isAnimating = false;
          });
        }
      });
      
      // Handle window resize
      let resizeTimeout: number;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = window.setTimeout(() => {
          if (isOpen && !isAnimating) {
            content.style.height = 'auto';
          }
        }, 150);
      });
    });
  });
</script>

