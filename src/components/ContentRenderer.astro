---
import type { ContentBlock, CollapsibleContent } from '../types/content.ts';
import CollapsibleContentComponent from './content/CollapsibleContent.astro';
import ConferenceCalendar from './content/ConferenceCalendar.astro';

export interface Props {
  blocks: ContentBlock[];
  collapsibleGroup?: string; // Optional group name for accordion behavior
}

const { blocks, collapsibleGroup } = Astro.props;
---

{blocks.map(block => {
  switch (block.type) {
    case 'title':
      return <h2 class="content-title">{block.content}</h2>;
    
    case 'subtitle':
      return <h3 class="content-subtitle">{block.content}</h3>;
    
    case 'text': {
      const content = Array.isArray(block.content) ? block.content.join(' ') : block.content;
      if (typeof content !== 'string') {
        return null;
      }
      
      // Parse markdown formatting: images first, then hyperlinks, then bold text
      let processedContent = content;
      
      // First, process images ![alt](src)
      processedContent = processedContent.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1" style="height: 80px; width: auto; margin-bottom: 1rem;" />');
      
      // Then, process hyperlinks [text](url)
      processedContent = processedContent.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" class="text-primary-600 hover:text-primary-800 underline" target="_blank" rel="noopener noreferrer">$1</a>');
      
      // Then process bold text **text**
      const parts = processedContent.split(/(\*\*.*?\*\*)/g);
      const parsedParts = parts.map((part: string) => {
        if (part.startsWith('**') && part.endsWith('**')) {
          return <strong>{part.slice(2, -2)}</strong>;
        }
        // Return as raw HTML for images and hyperlinks that were already processed
        if (part.includes('<img ') || part.includes('<a href=')) {
          return <span set:html={part}></span>;
        }
        return part;
      });
      
      return <p class="content-text">{parsedParts}</p>;
    }
    
    case 'list':
      return (
        <ul class="content-list">
          {Array.isArray(block.content) && block.content.map(item => {
            // Process markdown formatting within list items: images first, then hyperlinks, then other formatting
            const processedItem = item
              .replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1" style="height: 80px; width: auto; margin-bottom: 1rem;" />')
              .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" class="text-primary-600 hover:text-primary-800 underline" target="_blank" rel="noopener noreferrer">$1</a>')
              .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
              .replace(/\*(.*?)\*/g, '<em>$1</em>')
              .replace(/`(.*?)`/g, '<code>$1</code>');
            
            return <li set:html={processedItem}></li>;
          })}
        </ul>
      );
    
    case 'highlight':
      return (
        <div class="content-highlight">
          <p class="text-primary-800 font-medium m-0">{block.content}</p>
        </div>
      );
    
    case 'warning':
      return (
        <div class="content-warning">
          <div class="flex items-start">
            <svg class="w-5 h-5 text-amber-600 mr-3 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
            </svg>
            <p class="text-amber-800 font-medium m-0">{block.content}</p>
          </div>
        </div>
      );
    
    case 'success':
      return (
        <div class="content-success">
          <div class="flex items-start">
            <svg class="w-5 h-5 text-green-600 mr-3 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            <p class="text-green-800 font-medium m-0">{block.content}</p>
          </div>
        </div>
      );
    
    case 'info':
      return (
        <div class="bg-blue-50 border border-blue-200 rounded-lg p-6 mb-6">
          <div class="flex items-start">
            <svg class="w-5 h-5 text-blue-600 mr-3 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            <p class="text-blue-800 font-medium m-0">{block.content}</p>
          </div>
        </div>
      );
    
    case 'card':
      return (
        <div class="content-card">
          <p class="text-gray-700 m-0">{block.content}</p>
        </div>
      );
    
    case 'grid':
      if (typeof block.content === 'object' && 'columns' in block.content) {
        const columns = Number(block.content.columns);
        const gridClass = columns === 3 ? 'content-grid-3' : 
                          columns === 1 ? 'content-grid-1' : 'content-grid';
        
        // Parse markdown content in card items
        const parseCardMarkdown = (content: string) => {
          const lines = content.split('\n').map(line => line.trim()).filter(line => line);
          const elements = [];
          
          let i = 0;
          while (i < lines.length) {
            const line = lines[i];
            
            // Check if this is a list item
            if (line.startsWith('* ') || line.startsWith('- ')) {
              // Collect all consecutive list items
              const listItems = [];
              while (i < lines.length && (lines[i].startsWith('* ') || lines[i].startsWith('- '))) {
                const itemContent = lines[i].substring(2).trim();
              // Process markdown formatting in list item
                const processedItem = itemContent
                  .replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1" style="height: 80px; width: auto; margin-bottom: 1rem;" />')
                  .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" class="text-primary-600 hover:text-primary-800 underline" target="_blank" rel="noopener noreferrer">$1</a>')
                  .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                  .replace(/\*(.*?)\*/g, '<em>$1</em>')
                  .replace(/`(.*?)`/g, '<code>$1</code>');
                listItems.push(processedItem);
                i++;
              }
              
              // Create a list element
              elements.push(
                <ul class="list-disc list-inside space-y-1 text-sm">
                  {listItems.map(item => (
                    <li set:html={item}></li>
                  ))}
                </ul>
              );
            } else {
              // Regular text line - parse images, bold text and line breaks
              let processedLine = line;
              
              // Check if this line contains HTML content (like iframes or calendar)
              if (processedLine.includes('<iframe') || processedLine.includes('<div class="embed') || processedLine.includes('<calendar>')) {
                // Handle special calendar component
                if (processedLine.includes('<calendar>')) {
                  elements.push(<ConferenceCalendar />);
                  i++;
                  continue;
                }
                // Handle HTML embeds directly without markdown processing
                elements.push(<div class="mb-1" set:html={processedLine}></div>);
                i++;
                continue;
              }
              
              // Process images first
              processedLine = processedLine.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, '<img src="$2" alt="$1" style="height: 80px; width: auto; margin-bottom: 1rem;" />');
              // Then process hyperlinks
              processedLine = processedLine.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" class="text-primary-600 hover:text-primary-800 underline" target="_blank" rel="noopener noreferrer">$1</a>');
              
              const parts = processedLine.split(/(\*\*.*?\*\*)/);
              const parsedParts = parts.map(part => {
                if (part.startsWith('**') && part.endsWith('**')) {
                  return <strong>{part.slice(2, -2)}</strong>;
                }
                // Return as raw HTML for images and hyperlinks that were already processed
                if (part.includes('<img ') || part.includes('<a href=')) {
                  return <span set:html={part}></span>;
                }
                return part;
              });
              elements.push(<div class="mb-1">{parsedParts}</div>);
              i++;
            }
          }
          
          return elements;
        };
        
        return (
          <div class={gridClass}>
            {block.content.items.map(item => (
              <div class="bg-white rounded-lg p-6 shadow-sm border">
                <div class="flex items-center mb-3">
                  {item.icon && (
                    <div class="text-2xl mr-3">{item.icon}</div>
                  )}
                  <h4 class="font-semibold text-gray-900 m-0">{item.title}</h4>
                </div>
                <div class="text-gray-600 text-sm">
                  {parseCardMarkdown(item.content)}
                </div>
              </div>
            ))}
          </div>
        );
      }
      return null;
    
    case 'button':
      return (
        <div class="my-6">
          <a 
            href={block.url || '#'} 
            class="btn-primary"
          >
            {block.buttonText || block.content}
          </a>
        </div>
      );
    
    case 'status':
      const statusClass = `status-badge status-${block.status || 'coming-soon'}`;
      return (
        <div class="my-4">
          <span class={statusClass}>
            {block.status === 'coming-soon' && '⏳ '}
            {block.status === 'available' && '✅ '}
            {block.status === 'closed' && '❌ '}
            {block.content}
          </span>
        </div>
      );
    
    case 'collapsible':
      if (typeof block.content === 'object' && 'title' in block.content) {
        const collapsibleContent = block.content as CollapsibleContent;
        return <CollapsibleContentComponent content={collapsibleContent} group={collapsibleGroup} />;
      }
      return null;
    
    default:
      return null;
  }
})}
