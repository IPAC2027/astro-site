---
import type { ContentBlock, CollapsibleContent } from '../types/content.ts';

export interface Props {
  blocks: ContentBlock[];
}

const { blocks } = Astro.props;
---

{blocks.map(block => {
  switch (block.type) {
    case 'title':
      return <h2 class="content-title">{block.content}</h2>;
    
    case 'subtitle':
      return <h3 class="content-subtitle">{block.content}</h3>;
    
    case 'text': {
      const content = Array.isArray(block.content) ? block.content.join(' ') : block.content;
      if (typeof content !== 'string') {
        return null;
      }
      const parts = content.split(/(\*\*.*?\*\*)/g);
      const parsedParts = parts.map((part: string) => {
        if (part.startsWith('**') && part.endsWith('**')) {
          return <strong>{part.slice(2, -2)}</strong>;
        }
        return part;
      });
      return <p class="content-text">{parsedParts}</p>;
    }
    
    case 'list':
      return (
        <ul class="content-list">
          {Array.isArray(block.content) && block.content.map(item => {
            // Process markdown formatting within list items
            const processedItem = item
              .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
              .replace(/\*(.*?)\*/g, '<em>$1</em>')
              .replace(/`(.*?)`/g, '<code>$1</code>');
            
            return <li set:html={processedItem}></li>;
          })}
        </ul>
      );
    
    case 'highlight':
      return (
        <div class="content-highlight">
          <p class="text-primary-800 font-medium m-0">{block.content}</p>
        </div>
      );
    
    case 'warning':
      return (
        <div class="content-warning">
          <div class="flex items-start">
            <svg class="w-5 h-5 text-amber-600 mr-3 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
            </svg>
            <p class="text-amber-800 font-medium m-0">{block.content}</p>
          </div>
        </div>
      );
    
    case 'success':
      return (
        <div class="content-success">
          <div class="flex items-start">
            <svg class="w-5 h-5 text-green-600 mr-3 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            <p class="text-green-800 font-medium m-0">{block.content}</p>
          </div>
        </div>
      );
    
    case 'info':
      return (
        <div class="bg-blue-50 border border-blue-200 rounded-lg p-6 mb-6">
          <div class="flex items-start">
            <svg class="w-5 h-5 text-blue-600 mr-3 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            <p class="text-blue-800 font-medium m-0">{block.content}</p>
          </div>
        </div>
      );
    
    case 'card':
      return (
        <div class="content-card">
          <p class="text-gray-700 m-0">{block.content}</p>
        </div>
      );
    
    case 'grid':
      if (typeof block.content === 'object' && 'columns' in block.content) {
        const columns = Number(block.content.columns);
        const gridClass = columns === 3 ? 'content-grid-3' : 
                          columns === 1 ? 'content-grid-1' : 'content-grid';
        
        // Parse markdown content in card items
        const parseCardMarkdown = (content: string) => {
          const lines = content.split('\n').map(line => line.trim()).filter(line => line);
          const elements = [];
          
          let i = 0;
          while (i < lines.length) {
            const line = lines[i];
            
            // Check if this is a list item
            if (line.startsWith('* ') || line.startsWith('- ')) {
              // Collect all consecutive list items
              const listItems = [];
              while (i < lines.length && (lines[i].startsWith('* ') || lines[i].startsWith('- '))) {
                const itemContent = lines[i].substring(2).trim();
                // Process markdown formatting in list item
                const processedItem = itemContent
                  .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                  .replace(/\*(.*?)\*/g, '<em>$1</em>')
                  .replace(/`(.*?)`/g, '<code>$1</code>');
                listItems.push(processedItem);
                i++;
              }
              
              // Create a list element
              elements.push(
                <ul class="list-disc list-inside space-y-1 text-sm">
                  {listItems.map(item => (
                    <li set:html={item}></li>
                  ))}
                </ul>
              );
            } else {
              // Regular text line - parse bold text and line breaks
              const parts = line.split(/(\*\*.*?\*\*)/);
              const parsedParts = parts.map(part => {
                if (part.startsWith('**') && part.endsWith('**')) {
                  return <strong>{part.slice(2, -2)}</strong>;
                }
                return part;
              });
              elements.push(<div class="mb-1">{parsedParts}</div>);
              i++;
            }
          }
          
          return elements;
        };
        
        return (
          <div class={gridClass}>
            {block.content.items.map(item => (
              <div class="bg-white rounded-lg p-6 shadow-sm border">
                {item.icon && (
                  <div class="text-2xl mb-3">{item.icon}</div>
                )}
                <h4 class="font-semibold text-gray-900 mb-2">{item.title}</h4>
                <div class="text-gray-600 text-sm">
                  {parseCardMarkdown(item.content)}
                </div>
              </div>
            ))}
          </div>
        );
      }
      return null;
    
    case 'button':
      return (
        <div class="my-6">
          <a 
            href={block.url || '#'} 
            class="btn-primary"
          >
            {block.buttonText || block.content}
          </a>
        </div>
      );
    
    case 'status':
      const statusClass = `status-badge status-${block.status || 'coming-soon'}`;
      return (
        <div class="my-4">
          <span class={statusClass}>
            {block.status === 'coming-soon' && '⏳ '}
            {block.status === 'available' && '✅ '}
            {block.status === 'closed' && '❌ '}
            {block.content}
          </span>
        </div>
      );
    
    case 'collapsible':
      if (typeof block.content === 'object' && 'title' in block.content) {
        const collapsibleContent = block.content as CollapsibleContent;
        
        // Unified collapsible implementation - handles both nested blocks and markdown content
        const renderContent = () => {
          // If there are nested blocks, render them recursively
          if (collapsibleContent.nestedBlocks && collapsibleContent.nestedBlocks.length > 0) {
            return <Astro.self blocks={collapsibleContent.nestedBlocks} />;
          }
          
          // Otherwise, parse the markdown content
          if (collapsibleContent.content) {
            const lines = collapsibleContent.content.split('\n');
            const elements = [];
            
            for (let i = 0; i < lines.length; i++) {
              const trimmedLine = lines[i].trim();
              if (!trimmedLine) continue;
              
              // Handle headers
              if (trimmedLine.startsWith('### ')) {
                elements.push(<h3 class="text-lg font-semibold text-gray-900 mb-3 mt-4 first:mt-0">{trimmedLine.slice(4)}</h3>);
              } else if (trimmedLine.startsWith('## ')) {
                elements.push(<h2 class="text-xl font-semibold text-gray-900 mb-3 mt-4 first:mt-0">{trimmedLine.slice(3)}</h2>);
              } else if (trimmedLine.startsWith('* ') || trimmedLine.startsWith('- ')) {
                // Handle list items - collect consecutive ones
                const listItems = [];
                while (i < lines.length && (lines[i].trim().startsWith('* ') || lines[i].trim().startsWith('- '))) {
                  const itemContent = lines[i].trim().substring(2).trim();
                  const processedItem = itemContent
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>')
                    .replace(/`(.*?)`/g, '<code>$1</code>');
                  listItems.push(processedItem);
                  i++;
                }
                i--; // Back up one since the loop will increment
                
                elements.push(
                  <ul class="list-disc list-inside space-y-1 mb-4">
                    {listItems.map(item => (
                      <li set:html={item}></li>
                    ))}
                  </ul>
                );
              } else {
                // Regular paragraph - parse bold text
                const parts = trimmedLine.split(/(\*\*.*?\*\*)/);
                const parsedParts = parts.map((part: string) => {
                  if (part.startsWith('**') && part.endsWith('**')) {
                    return <strong>{part.slice(2, -2)}</strong>;
                  }
                  return part;
                });
                elements.push(<p class="mb-3 leading-relaxed">{parsedParts}</p>);
              }
            }
            
            return elements;
          }
          
          return null;
        };
        
        return (
          <details class="mb-6 border border-gray-200 rounded-lg overflow-hidden" open={collapsibleContent.isOpen}>
            <summary class="px-6 py-4 bg-gray-50 hover:bg-gray-100 cursor-pointer transition-colors duration-200 border-b border-gray-200">
              <span class="font-medium text-gray-900">{collapsibleContent.title}</span>
            </summary>
            <div class="px-6 py-4 bg-white">
              <div class="prose prose-sm max-w-none text-gray-700">
                {renderContent()}
              </div>
            </div>
          </details>
        );
      }
      return null;
    
    default:
      return null;
  }
})}
