---
import type { ContentBlock } from '../types/content.ts';

export interface Props {
  blocks: ContentBlock[];
}

const { blocks } = Astro.props;
---

{blocks.map(block => {
  switch (block.type) {
    case 'title':
      return <h2 class="content-title">{block.content}</h2>;
    
    case 'subtitle':
      return <h3 class="content-subtitle">{block.content}</h3>;
    
    case 'text': {
      const content = Array.isArray(block.content) ? block.content.join(' ') : block.content;
      if (typeof content !== 'string') {
        return null;
      }
      const parts = content.split(/(\*\*.*?\*\*)/g);
      const parsedParts = parts.map((part: string) => {
        if (part.startsWith('**') && part.endsWith('**')) {
          return <strong>{part.slice(2, -2)}</strong>;
        }
        return part;
      });
      return <p class="content-text">{parsedParts}</p>;
    }
    
    case 'list':
      return (
        <ul class="content-list">
          {Array.isArray(block.content) && block.content.map(item => {
            // Process markdown formatting within list items
            const processedItem = item
              .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
              .replace(/\*(.*?)\*/g, '<em>$1</em>')
              .replace(/`(.*?)`/g, '<code>$1</code>');
            
            return <li set:html={processedItem}></li>;
          })}
        </ul>
      );
    
    case 'highlight':
      return (
        <div class="content-highlight">
          <p class="text-primary-800 font-medium m-0">{block.content}</p>
        </div>
      );
    
    case 'warning':
      return (
        <div class="content-warning">
          <div class="flex items-start">
            <svg class="w-5 h-5 text-amber-600 mr-3 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
            </svg>
            <p class="text-amber-800 font-medium m-0">{block.content}</p>
          </div>
        </div>
      );
    
    case 'success':
      return (
        <div class="content-success">
          <div class="flex items-start">
            <svg class="w-5 h-5 text-green-600 mr-3 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            <p class="text-green-800 font-medium m-0">{block.content}</p>
          </div>
        </div>
      );
    
    case 'info':
      return (
        <div class="bg-blue-50 border border-blue-200 rounded-lg p-6 mb-6">
          <div class="flex items-start">
            <svg class="w-5 h-5 text-blue-600 mr-3 mt-0.5 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
            </svg>
            <p class="text-blue-800 font-medium m-0">{block.content}</p>
          </div>
        </div>
      );
    
    case 'card':
      return (
        <div class="content-card">
          <p class="text-gray-700 m-0">{block.content}</p>
        </div>
      );
    
    case 'grid':
      if (typeof block.content === 'object' && 'columns' in block.content) {
        const columns = Number(block.content.columns);
        const gridClass = columns === 3 ? 'content-grid-3' : 
                          columns === 1 ? 'content-grid-1' : 'content-grid';
        
        // Parse markdown content in card items
        const parseCardMarkdown = (content: string) => {
          const lines = content.split('\n').map(line => line.trim()).filter(line => line);
          const elements = [];
          
          let i = 0;
          while (i < lines.length) {
            const line = lines[i];
            
            // Check if this is a list item
            if (line.startsWith('* ') || line.startsWith('- ')) {
              // Collect all consecutive list items
              const listItems = [];
              while (i < lines.length && (lines[i].startsWith('* ') || lines[i].startsWith('- '))) {
                const itemContent = lines[i].substring(2).trim();
                // Process markdown formatting in list item
                const processedItem = itemContent
                  .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                  .replace(/\*(.*?)\*/g, '<em>$1</em>')
                  .replace(/`(.*?)`/g, '<code>$1</code>');
                listItems.push(processedItem);
                i++;
              }
              
              // Create a list element
              elements.push(
                <ul class="list-disc list-inside space-y-1 text-sm">
                  {listItems.map(item => (
                    <li set:html={item}></li>
                  ))}
                </ul>
              );
            } else {
              // Regular text line - parse bold text and line breaks
              const parts = line.split(/(\*\*.*?\*\*)/);
              const parsedParts = parts.map(part => {
                if (part.startsWith('**') && part.endsWith('**')) {
                  return <strong>{part.slice(2, -2)}</strong>;
                }
                return part;
              });
              elements.push(<div class="mb-1">{parsedParts}</div>);
              i++;
            }
          }
          
          return elements;
        };
        
        return (
          <div class={gridClass}>
            {block.content.items.map(item => (
              <div class="bg-white rounded-lg p-6 shadow-sm border">
                {item.icon && (
                  <div class="text-2xl mb-3">{item.icon}</div>
                )}
                <h4 class="font-semibold text-gray-900 mb-2">{item.title}</h4>
                <div class="text-gray-600 text-sm">
                  {parseCardMarkdown(item.content)}
                </div>
              </div>
            ))}
          </div>
        );
      }
      return null;
    
    case 'button':
      return (
        <div class="my-6">
          <a 
            href={block.url || '#'} 
            class="btn-primary"
          >
            {block.buttonText || block.content}
          </a>
        </div>
      );
    
    case 'status':
      const statusClass = `status-badge status-${block.status || 'coming-soon'}`;
      return (
        <div class="my-4">
          <span class={statusClass}>
            {block.status === 'coming-soon' && '⏳ '}
            {block.status === 'available' && '✅ '}
            {block.status === 'closed' && '❌ '}
            {block.content}
          </span>
        </div>
      );
    
    case 'collapsible':
      if (typeof block.content === 'object' && 'title' in block.content) {
        // If there are nested blocks, render them, otherwise use the markdown parser
        if (block.content.nestedBlocks && block.content.nestedBlocks.length > 0) {
          return (
            <details class="mb-6 border border-gray-200 rounded-lg overflow-hidden" open={block.content.isOpen}>
              <summary class="px-6 py-4 bg-gray-50 hover:bg-gray-100 cursor-pointer transition-colors duration-200 border-b border-gray-200">
                <span class="font-medium text-gray-900">{block.content.title}</span>
              </summary>
              <div class="px-6 py-4 bg-white">
                <div class="prose prose-sm max-w-none text-gray-700">
                  <Astro.self blocks={block.content.nestedBlocks} />
                </div>
              </div>
            </details>
          );
        } else {
          // Parse basic markdown content 
          const parseMarkdownContent = (content: string) => {
            const lines = content.split('\n');
            const elements = [];
            
            for (let i = 0; i < lines.length; i++) {
              const trimmedLine = lines[i].trim();
              if (!trimmedLine) continue;
              
              // Handle headers
              if (trimmedLine.startsWith('### ')) {
                elements.push(<h3 class="text-lg font-semibold text-gray-900 mb-3 mt-4 first:mt-0">{trimmedLine.slice(4)}</h3>);
              } else if (trimmedLine.startsWith('## ')) {
                elements.push(<h2 class="text-xl font-semibold text-gray-900 mb-3 mt-4 first:mt-0">{trimmedLine.slice(3)}</h2>);
              } else {
                // Parse bold text in paragraphs
                const parts = trimmedLine.split(/(\*\*.*?\*\*)/);
                const parsedParts = parts.map(part => {
                  if (part.startsWith('**') && part.endsWith('**')) {
                    return <strong>{part.slice(2, -2)}</strong>;
                  }
                  return part;
                });
                elements.push(<p class="mb-3 leading-relaxed">{parsedParts}</p>);
              }
            }
            
            return elements;
          };
          
          return (
            <details class="mb-6 border border-gray-200 rounded-lg overflow-hidden" open={block.content.isOpen}>
              <summary class="px-6 py-4 bg-gray-50 hover:bg-gray-100 cursor-pointer transition-colors duration-200 border-b border-gray-200">
                <span class="font-medium text-gray-900">{block.content.title}</span>
              </summary>
              <div class="px-6 py-4 bg-white">
                <div class="prose prose-sm max-w-none text-gray-700">
                  {block.content.nestedBlocks ? 
                    block.content.nestedBlocks.map((nestedBlock: any) => {
                      if (nestedBlock.type === 'grid' && nestedBlock.content && typeof nestedBlock.content === 'object' && 'columns' in nestedBlock.content && 'items' in nestedBlock.content) {
                        const { columns, items } = nestedBlock.content;
                        const gridClass = columns === 2 ? 'content-grid' : columns === 3 ? 'content-grid-3' : 'content-grid-1';
                        
                        return (
                          <div class={gridClass}>
                            {items.map((item: any) => (
                              <div class="bg-white rounded-lg p-6 shadow-sm border">
                                {item.title && (
                                  <h4 class="font-semibold text-gray-900 mb-2">{item.title}</h4>
                                )}
                                <div class="text-gray-600 text-sm">
                                  {item.content.split('\n').map((line: string) => {
                                    if (line.trim()) {
                                      if (line.includes('**')) {
                                        const parts = line.split(/(\*\*[^*]+\*\*)/);
                                        const parsedParts = parts.map((part: string) => {
                                          if (part.startsWith('**') && part.endsWith('**')) {
                                            return <strong>{part.slice(2, -2)}</strong>;
                                          }
                                          return part;
                                        });
                                        return <div class="mb-1">{parsedParts}</div>;
                                      } else {
                                        return <div class="mb-1">{line}</div>;
                                      }
                                    }
                                    return null;
                                  })}
                                </div>
                              </div>
                            ))}
                          </div>
                        );
                      }
                      return null;
                    }) :
                    parseMarkdownContent(block.content.content)
                  }
                </div>
              </div>
            </details>
          );
        }
      }
      return null;
    
    default:
      return null;
  }
})}
